Version Control (First Things First)

I can't remember who told me this, but it's always stuck with me and served me well: when you make any change to a system, ask yourself if it improves the "three Ss": Security, Stability, and Scalability - in that order.

When people think of security, their first thought usually goes to a hooded hacker in a dark room, tapping out l33t exploits. But before worryng about external threats, programmers should concern themselves with a more common and fundamental aspect of security: data.

In the implicit contract between a programmer and a user, the programmer has no responsibility more important than to protect the user's data. And when it comes to code, the programmer is also one of the users. 

The way to protect code, but still allow it flexibility, is version control. It's sheer folly to attempt software development without it.

Software development is tremendously complicated. In fact I think that's half the job - in my opinion, the two tasks developers execute are translating requirements and managing complexity. Version control helps to manage complexity by allowing you to see what state the code was in at any given time. 

Novice developers often misunderstand this function of version control. Seeing the state does not mean that each version in the system needs to be perfect. If you have a syntax error, or, god forbid, a bug in a previous version, you leave it there.

You leave in the mistakes. You fix them in the latest version, you don't go back and fix them retroactively. 

You need to know how the code looked and behaved in the past. If you change it, you may later find outputs generated by that code that can no longer be reconstructed from it. Say someone brings you a report from two months ago, wanting to know why some piece of data appears the way it does. If you've changed how the state of the code looked at the time it generated, you can't explain.

From a practical perspective, it utterly negates the complexity management benefit of version control. Retroactive changes have a ripple effect in version history - the farther back the change, the more places it will affect in the present. You can get away with cleaning up a work in progress if you haven't pushed to the remote yet. But it still has to be very important not to be outweighed by the cost - changing history is complicated. 

Last, a strong case can be made it's at least vain, if not dishonest. I don't write perfect code 100% of the time, and neither do you. The bell curve of code falls in the "good enough" spectrum, so insisting your precious code needs to look perfect from every angle - not just in the present but also the past - feels immature. 

Taking my own advice, I'm leaving in several of the next few commits, even though I decided against them and removed their changes in XXXXXXXX. I'll detail my reasoning there, but this explains why some commentary may be missing. 


